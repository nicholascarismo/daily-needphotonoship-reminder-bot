name: Keep Render Warm (daily-needphotonoship-reminder)

on:
  schedule:
    - cron: "*/10 * * * *"
  workflow_dispatch:

concurrency:
  group: keepalive-daily-needphotonoship-reminder
  cancel-in-progress: true

jobs:
  warm:
    runs-on: ubuntu-latest
    timeout-minutes: 8
    steps:
      - name: Define URL & jitter
        id: defs
        shell: bash
        run: |
          echo "BASE=https://daily-needphotonoship-reminder.onrender.com" >> "$GITHUB_OUTPUT"
          echo "TS=$(date +%s)" >> "$GITHUB_OUTPUT"
          echo "JITTER=$((RANDOM % 12))" >> "$GITHUB_OUTPUT"

      - name: Jitter sleep (avoid thundering herd)
        shell: bash
        run: sleep ${{ steps.defs.outputs.JITTER }}

      - name: Warm with GitHub Script (no curl)
        uses: actions/github-script@v7
        env:
          BASE: ${{ steps.defs.outputs.BASE }}
          TS: ${{ steps.defs.outputs.TS }}
        with:
          script: |
            const base = process.env.BASE;
            const ts = process.env.TS;

            async function hit(path, timeoutMs, label) {
              const u = `${base}${path}${path.includes('?') ? '&' : '?'}ts=${ts}${label ? `&${label}` : ''}`;
              const ac = new AbortController();
              const t = setTimeout(() => ac.abort(), timeoutMs);
              try {
                const res = await fetch(u, { method: 'GET', redirect: 'follow', signal: ac.signal });
                return res.status;
              } catch (e) {
                core.info(`fetch error for ${u}: ${e.name || e}`);
                return 0;
              } finally {
                clearTimeout(t);
              }
            }

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            core.info(`Fast warmup nudges against ${base} ...`);

            // Fast nudges
            for (let i = 1; i <= 6; i++) {
              for (const p of ["/", "/health"]) {
                const code = await hit(p, 6000, `nudge=${i}`);
                core.info(`nudge ${i} ${p} -> ${code || "<none>"}`);
                if (code === 200) {
                  core.info("✅ Service responded during fast warmup");
                  return;
                }
              }
              await sleep(3000);
            }

            core.info("Proceeding to bounded health checks...");

            // Bounded health checks
            for (let i = 1; i <= 12; i++) {
              core.info(`health attempt ${i} ...`);
              const code = await hit("/health", 20000, `try=${i}`);
              core.info(`HTTP ${code || "<none>"}`);
              if (code === 200) {
                core.info("✅ Warm OK");
                return;
              }
              if (i < 12) await sleep(5000);
            }

            core.setFailed(`❌ Could not reach ${base}/health with HTTP 200 after bounded retries`);

      - name: Optional /version sanity (non-fatal)
        uses: actions/github-script@v7
        continue-on-error: true
        env:
          BASE: ${{ steps.defs.outputs.BASE }}
        with:
          script: |
            const base = process.env.BASE;
            try {
              const r = await fetch(`${base}/version?ts=${Date.now()}`);
              core.info(`version status: ${r.status}`);
              const text = await r.text();
              core.info(text.slice(0, 400));
            } catch (e) {
              core.info(`version fetch failed: ${e.name || e}`);
            }

      - name: Notify Slack on failure (optional)
        if: failure()
        uses: actions/github-script@v7
        env:
          WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
        with:
          script: |
            const webhook = process.env.WEBHOOK;
            if (!webhook) { core.info('No WEBHOOK set; skipping Slack notify'); return; }
            const payload = {
              text: [
                '❌ *Keep Render Warm (daily-needphotonoship-reminder)* failed.',
                `Repo: ${context.repo.owner}/${context.repo.repo}`,
                `Run: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`
              ].join('\n')
            };
            const res = await fetch(webhook, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            });
            core.info(`Slack webhook status: ${res.status}`);